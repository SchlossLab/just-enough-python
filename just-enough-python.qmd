---
title: "Just Enough Python"
author: "Kelly Sovacool"
aliases: 
    - index.html
engine: knitr
code-tools:
    source: https://github.com/SchlossLab/just-enough-python/blob/main/just-enough-python.qmd
css: custom.css
toc: true
format:
  html:
    code-line-numbers: true
    code-link: true
---

Snakemake is extra magic on top of Python. If you want to take your Snakemake 
workflows from beginner to advanced, learning a little Python goes a long way.

This is just enough Python to understand and apply some cool tricks in your Snakemake workflows.


###  Prereqs

- Basic snakemake knowledge. you've gone through the official tutorial. 
  maybe you've even tried building your own snakemake workflow.
- Minimal or no python knowledge outside of what you may have gleaned from the snakemake docs.
- Basic R experience.


## Variables

### basic data types

| Python  | R         |
|---------|-----------|
| string  | character |
| integer | integer   |
| float   | numeric   |
| boolean | logical   |
| None    | NULL      |

```{python py-types}
#| filename: "Python"

# string
name = "Kelly"
favorite_color = 'green'
# float
height_inches = 64.0
# int
num_plants = 14
# bool
likes_cats = True
# none
invalid = None
```

```{r r-types}
#| filename: "R"

# character
name <- "Kelly"
favorite_color <- 'green'
# numeric
height_inches <- 64
# integer
num_plants <- 14L
# logical
likes_cats <- TRUE
# null
invalid = NULL
```

#### type casting

```{python type-cast}
#| filename: "Python"
int(32.0)
float(32)
str(32)
bool(0)
bool(1)
bool(None)
```

#### Naming variables

Biggest difference between R and Python: no dots are allowed in Python variable names.
All other rules from R apply. Python variable names must start with an alphabetic character and they can contain alphanumeric characters and underscores.

Just like in R, it is a good idea not to name a variable the same thing as a 
reserved keyword or global function.

```{python}
#| filename: "Python keywords"
help("keywords")
```

#### formatting strings

You can add strings together to build new ones like this:

```{python}
#| filename: "Python"
firstname = "Marie"
lastname = "Curie"
middle_init = 'S'
prefix = "Madame"

fullname = prefix + " " + firstname + " " + middle_init + ". " + lastname
print(fullname)
```

The print function takes any number of arguments and will insert a space between
items by default:

```{python}
#| filename: "Python"
print(prefix, firstname, middle_init + ".", lastname)
```

But there's a better way!

**f-Strings** in Python work just like `glue()` in R, where curly braces in the 
string are interpreted as code. They're much easier to read & write:

```{python}
#| filename: "Python"
f"{prefix} {firstname} {middle_init}. {lastname}"
```

This is equivalent to:

```{R}
#| filename: "R"
glue::glue("{prefix} {firstname} {middle_init}. {lastname}")
```


### types that contain other types

| Python             | R              |
|--------------------|----------------|
| list               | vector (all same type) or list (multiple types) |
| dictionary         | named list     |
| dataframe (pandas) | dataframe (base) or tibble (tidyverse) |

#### lists

```{python py-lists}
#| filename: "Python"
fruit = ['apple','banana','grape']
my_list = ['pizza', 'fries', 3, -2.5, 'donuts']
fruit + my_list
fruit.append('mango')
fruit
```

Indexing is 0-based in Python.
You might find 0-based indexing unintuitive if you're used to working in 
languages like R that use 1-based indexing.

```{python index}
#| filename: "Python"
numbers = [1,2,3,4]
len(numbers) # length
numbers[0] # first item
numbers[3] # last item
numbers[-1] # last item
```


#### dictionaries

Dictionaries consist of key-value pairs where you use the key to access the value.
Keys can be strings, integers, floats, or booleans. Values can be anything!

```{python}
#| filename: "Python"
foods = {'vegetable': ['carrot', 'eggplant'], 
         'fruit': 'cherry'}
foods['fruit']
foods['vegetable']
foods['vegetable'][0]
```

Dictionaries can be nested:

```{python}
#| filename: "Python"
hyperparams = {'glmnet': {'alpha': [0, 0.5, 1],
                          'lambda': [0.01, 0.1, 0, 1]
                          },
                'rf': {'mtry': [128, 256, 512]}
               }
hyperparams['glmnet']['alpha'][1]
```

##### Snakemake config

Say you have a Snakemake workflow for training machine learning models.
You want to be able to specify different datasets, ML methods, and random seeds, so 
you use f-Strings to fill in these variables:

```{python}
#| filename: "Snakefile"
#| eval: false
dataset = "OTU"
method = "rf"
seed = 1001

rule trail_ml_model:
    input:
        R="workflow/scripts/train_ml.R",
        csv=f"data/{dataset}.csv"
    output:
        model=f"results/{dataset}/runs/{method}_{seed}_model.Rds"
    script:
        "scripts/train_ml.R"
```

You can improve this by creating a configuration file in YAML format:

```{YAML}
#| filename: "config/default.yml"
#| eval: false
dataset: 'OTU'
method: 'rf'
seed: 1001
```

Then specify your config file at the top of your Snakefile.
Snakemake parses your YAML config files to a dictionary called `config`.

```{python}
#| filename: "Snakefile"
#| eval: false
configfile: "config/default.yml"

dataset = config["dataset"]
method = config['rf']
seed = config['seed']

rule trail_ml_model:
    input:
        R="workflow/scripts/train_ml.R",
        csv=f"data/{dataset}.csv"
    output:
        model=f"results/{dataset}/runs/{method}_{seed}_model.Rds"
    script:
        "scripts/train_ml.R"
```


When you run this workflow, it uses `config/default.yml` by default:

```{bash}
#| filename: sh
#| eval: false
snakemake --configfile config/test.yml
```

```{bash}
#| eval: false
rule trail_ml_model:
    input: workflow/scripts/train_ml.R, data/OTU.csv
    output: results/OTU/runs/rf_1001_model.Rds
    jobid: 0
    reason: Missing output files: results/OTU/runs/rf_1001_model.Rds
    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T

Job stats:
job               count    min threads    max threads
--------------  -------  -------------  -------------
trail_ml_model        1              1              1
total                 1              1              1
```


Now you can change the values of these variables by editing the config file,
or by creating multiple config files and specifying them on the command line:

```{YAML}
#| filename: "config/genus.yml"
#| eval: false
dataset: 'genus'
method: 'glmnet'
seed: 1001
```


```{bash}
#| filename: sh
#| eval: false
snakemake --configfile config/test.yml
```

```{bash}
#| eval: false
rule trail_ml_model:
    input: workflow/scripts/train_ml.R, data/genus.csv
    output: results/genus/runs/glmnet_1001_model.Rds
    jobid: 0
    reason: Missing output files: results/genus/runs/glmnet_1001_model.Rds
    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T

Job stats:
job               count    min threads    max threads
--------------  -------  -------------  -------------
trail_ml_model        1              1              1
total                 1              1              1
```



## conditionals

Think of these as functions that return a boolean.

| operator | meaning                  | same in R |
|----------|--------------------------|-----------|
| `==`     | equal                    | ✅        |
| `!=`     | not equal                | ✅        |
| `<`      | less than                | ✅        |
| `>`      | greater than             | ✅        |
| `<=`     | less than or equal to    | ✅        |
| `>=`     | greater than or equal to | ✅        |
| or       | or (inclusive)           | `|`       |
| and      | and                      | `&`       |
| in       | in                       | `%in%`    |
| not      | not                      | `!`       |

```{python}
3 > 2
True or False
```

### if-else statements

No curly braces here! But indentation does matter.

```{python}
#| filename: "Python"
if len(my_list) < 10:
    list_description = "This list is short"
elif len(my_list) >= 10 and len(my_list) < 15:
    list_description = "This list is medium length"
else:
    list_description = "This list is long!"
print(list_description)
```

#### inline if-else statement

When you create a variable with an if-else statement, 
you can do it all on one line:

```{python}
list_description = "short" if len(my_list) < 10 else "not short"
```

This is equivalent to:

```{python}
if len(my_list) < 10:
    list_description = "short"
else:
    list_description = "not short"
```

You can't make it a one-liner if you need to use `elif`.

#### nested if-else blocks

```{python}
#| filename: "Python"
num = 1
if num >= 0:
    if num == 0:
        print("zero")
    else:
        print("positive")
else:
    print("negative")
```


## for loops

If a variable has a length (i.e. you can run `len(myvar)`), then you can 
**iterate** over it in a for loop.

```{python}
#| filename: "Python"
postdocs = ['Allison Mason', 'Courtney Armour', 'Sarah Lucas']
for person in postdocs:
    print(f"{person}, PhD")
```

### range

Use `range()` to loop over a range of numbers. If you give `range()` two arguments,
range starts counting from the first argument and stops _just before_ the second argument,
stepping by 1.
In other words, the stop argument is _exclusive_.

```{python}
#| filename: "Python"
num_bottles = 3
for i in range(1, num_bottles+1):
    print(i, " bottles of pop on the wall")
```

If you give range just one argument, it starts counting from zero and uses
the argument as the stop value:
```{python}
#| filename: "Python"
num_bottles = 3
for i in range(num_bottles+1):
    print(i, " bottles of pop on the wall")
```

You can also use `range()` to create lists:

```{python}
#| filename: "Python"
mylist = list(range(3))
mylist
```

You can use range with three arguments: `start`, `stop`, and `step`:

```{python}
#| filename: "Python"
list(range(2, 11, 2))
```

Give the `step` argument a negative value and make `start` greater than `stop` to move backwards:
```{python}
#| filename: "Python"
list(range(4, -7, -2))
```

You might think it's weird that range stops just _before_ the stop value.
But it works nicely when you give it the length of the list -- now you have the list indices!

```{python}
#| filename: "Python"
for i in range(len(numbers)):
    print(f"index {i} is {numbers[i]}")
```


### iterate over dictionaries

```{python}
#| filename: "Python"
problems = {1: "naming things", 2: "understanding binary", 3: "off-by-one errors"}
print('There are only 10 hard problems in computer science:')
for num in problems:
    print("\t", num, problems[num])
```


### comprehensions

when you want to make a for loop that creates a new list, dictionary, or set,
use a **comprehension**.


#### list comprehensions


To build a list with a for loop, you can do this
```{python list-comp-for}
#| filename: "Python"
squares = []
for i in range(4):
    squares.append(i**2)
squares
```

but a list comprehension is much sleeker and performs faster:
```{python list-comp}
#| filename: "Python"
squares = [i**2 for i in range(4)]
```

this is roughly equivalent to using *apply functions in R:

```{r apply}
#| filename: "R"
sapply(0:3, function(x) {x**2})
```

##### Snakemake expand

Let's say you have a Snakemake workflow with a rule that should run multiple times
with different parameters. For example, you may want to train machine learning models
with different ML methods, datasets, and random seeds. 
You define these as `wildcards` in a rule to train each ML model:

```{python}
#| filename: "Snakefile"
#| eval: false

rule trail_ml_model:
    input:
        R="workflow/scripts/train_ml.R",
        csv="data/{dataset}.csv"
    output:
        model="results/{dataset}/runs/{method}_{seed}_model.Rds"
    script:
        "scripts/train_ml.R"
```

You want snakemake to fill in certain values for these wildcards, so you create 
lists with the values you want and write a target rule at the top of your Snakefile.

You could use an f-String and a list comprehension to create the list of target files.

```{python}
datasets = ['OTU', 'genus']
methods = ['rf', 'glmnet', 'svmRadial']
seeds = range(1000, 1005)
[f"results/{dataset}/runs/{method}_{seed}_model.Rds" for dataset in datasets for method in methods for seed in seeds]
```

Here's what your Snakefile looks like now.

```{python}
#| filename: "Snakefile"
#| eval: false

datasets = ['OTU', 'genus']
methods = ['rf', 'glmnet', 'svmRadial']
seeds = range(1000, 1005)

rule targets:
    input:
        [f"results/{dataset}/runs/{method}_{seed}_model.Rds" for dataset in datasets for method in methods for seed in seeds]

rule trail_ml_model:
    input:
        R="workflow/scripts/train_ml.R"
    output:
        model="results/{dataset}/runs/{method}_{seed}_model.Rds"
    script:
        "scripts/train_ml.R"
```

The list comprehension gets harder to read the more `for` statements you add to it.
So Snakemake provides a function `expand()` to clean this up:

```{python}
#| filename: "Snakefile"
#| eval: false

datasets = ['OTU', 'genus']
methods = ['rf', 'glmnet', 'svmRadial']
seeds = range(1000, 1005)

rule targets:
    input:
        expand("results/{dataset}/runs/{method}_{seed}_model.Rds", 
                dataset = datasets, method = methods, seed = seeds)

rule trail_ml_model:
    input:
        R="workflow/scripts/train_ml.R"
    output:
        model="results/{dataset}/runs/{method}_{seed}_model.Rds"
    script:
        "scripts/train_ml.R"
```

Using `expand()` creates the exact same list as the list comprehension, but it's
much easier to read and add variables to.

#### dictionary comprehensions

```{python}
#| filename: "Python"
movies = ['star wars episode V', 'the godfather', 'the dark knight']
years = [1980, 1972, 2008]
movie_dict = {}
for movie, year in zip(movies, years):
    movie_dict[movie] = year
movie_dict
```


```{python}
#| filename: "Python"
movies = ['star wars episode V', 'the godfather', 'the dark knight']
years = [1980, 1972, 2008]
movie_dict = {movie: year for movie, year in zip(movies, years)}
```


## functions

in R: 

```{R r-function}
#| filename: "R"
square <- function(x) {
    return(x^2)
}

square(2)
```

in Python:

```{python py-function}
#| filename: "Python"
def square(x):
    return x**2

square(2)
```


### anonymous functions

Sometimes you want to write a simple function that you only use once.
They're so inconsequential you don't even want to give them a name.

We've already used one in R^[more on anonymous functions here: <http://adv-r.had.co.nz/Functional-programming.html#anonymous-functions>] inside `sapply()`:

```{R r-anon}
#| filename: "R"
function(x) { x**2 }
```


in Python you use the `lambda` keyword:

```{python py-anon}
#| filename: "Python"
lambda x: x**2
```

Before the colon, list the arguments of the function.
After the colon, compute the value that the function should return.


## object-oriented programming

i wish i could justify covering classes and object-oriented programming in depth,
but i'm only going to scratch the surface.

Everything in Python is an object. This is also true in R.

You can find out what class an object belongs to in Python with `type()`:

```{python}
#| filename: "Python"
type(numbers)
type(name)
type(name) == str
```

or in R with `class()`:

```{r}
#| filename: "R"
class(1:3)
class(list(1, 2, 3))
class(name)
class(name) == 'character'
```


#### Objects of different classes have different attributes and methods.

- attributes: metadata associated with an object.
- methods: functions that operate on an object.


Lists have methods that can modify them in place

```{python}
#| filename: "Python"
print(numbers)
numbers.append(5)
numbers.reverse()
print(numbers)
```

Strings can't be modified in place, but you can  methods

join
split


```{python}
filename = "path/to/file.txt"
filename.split('.')
filename.split('.')[0]
```


## Packages

Using packages works a little differently between R and Python.

In R, you can refer to a function from any package you have installed with double colons:

```{R pkg-syntax}
#| filename: R script
#| eval: false
dplyr::tibble(a = 1:3, b = 4:6)
```

Alternatively, you can first load the package at the top of your script so you
can call the functions you want to use without specifying the package name every
time you use them.

```{R library}
#| filename: R script
#| eval: false
library(dplyr)
tibble(a = 1:5, b = 6:10) %>%
    filter(a > 3)
```


In Python, you must `import` a package before you can use anything from it and
reference the package name like this:

```{Python import-pkg}
#| filename: Python script
#| eval: false
import pandas
pandas.DataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})
```

You can give a package a nickname to cut down on the characters you have to type.
`pandas` is often renamed to `pd`:


```{Python import-pkg-pd}
#| filename: Python script
#| eval: false
import pandas as pd
DataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})
```

Alternatively, you can choose to import only the functions you want to use from a package:

```{Python import-pkg-dataframe}
#| filename: Python script
#| eval: false
from pandas import DataFrame
DataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})
```

<!--
# topics i wish i had time to cover 

## mutability

## iterables, iterators, generators

## reading & writing files
-->


# Applying Python tricks to Snakemake 
TODO: COLLATE THESE WITH python concepts above

config files get imported as dictionaries

use f-Strings all the time

use lambda functions

input.name syntax is because of OOP

# Recap: Snakemake concepts covered

- Use f-Strings for pretty string formatting.
- Config files are imported as dictionaries. 


# Resources

- The Python docs: <https://docs.python.org/3/>
