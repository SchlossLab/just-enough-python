{
  "hash": "719d09936c4e95736be3983b4843bb4e",
  "result": {
    "markdown": "---\ntitle: \"Just A Little More Python\"\nsubtitle: \"than what I could cover in Just Enough Python\"\ndate: last-modified\nengine: knitr\n---\n\n\nI wish I had time to cover everything in-depth, but then I'd have to change the \ntitle from \"[Just Enough Python](index.qmd)\" to \"Way More Python \nThan We Could Possibly Cover In An Hour\". \nSo as a compromise, here's just a little more Python.\n\n<!--\n# topics i wish i had time to cover \n## mutability\n## iterables, iterators, generators\n### range returns somehting like a generator. lazy evaluation.\n## reading & writing files\n## tupes, named tupes. for snakemake wildcards\n## snakemake params - use lambda with wildcards & output args\n\nTODO\n-->\n### more comprehensions\n\n#### dictionary comprehensions\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nmovies = ['star wars episode V', 'the godfather', 'the dark knight']\nyears = [1980, 1972, 2008]\nmovie_dict = {}\nfor movie, year in zip(movies, years):\n    movie_dict[movie] = year\nmovie_dict\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'star wars episode V': 1980, 'the godfather': 1972, 'the dark knight': 2008}\n```\n:::\n:::\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nmovies = ['star wars episode V', 'the godfather', 'the dark knight']\nyears = [1980, 1972, 2008]\nmovie_dict = {movie: year for movie, year in zip(movies, years)}\n```\n:::\n\n\n#### set comprehensions\n\nUse a set instead of a list when order doesn't matter and you want every item\nto be unique. \n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nmyset = set([1,2,2,2,3,3,4])\nprint(myset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4}\n```\n:::\n:::\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\npresidents = [\"George Washington\", \"John Adams\", \"Thomas Jefferson\", \n              \"James Madison Jr\", \"James Monroe\", \"John Quincy Adams\"]\nfirst_names = {name.split()[0] for name in presidents}\nprint(first_names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'George', 'James', 'John', 'Thomas'}\n```\n:::\n:::\n\n\nLooking up whether a set contains an item is more efficient than using a list.\n\n## packages\n\nUsing packages works a little differently between R and Python.\n\nIn R, you can refer to a function from any package you have installed with double colons:\n\n\n::: {.cell filename='R script'}\n\n```{.r .cell-code}\ndplyr::tibble(a = 1:3, b = 4:6)\n```\n:::\n\n\nAlternatively, you can first load the package at the top of your script so you\ncan call the functions you want to use without specifying the package name every\ntime you use them.\n\n\n::: {.cell filename='R script'}\n\n```{.r .cell-code}\nlibrary(dplyr)\ntibble(a = 1:5, b = 6:10) %>%\n    filter(a > 3)\n```\n:::\n\n\n\nIn Python, you must `import` a package before you can use anything from it and\nreference the package name like this:\n\n\n::: {.cell filename='Python script'}\n\n```{.python .cell-code}\nimport pandas\npandas.DataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})\n```\n:::\n\n\nYou can give a package a nickname to cut down on the characters you have to type.\n`pandas` is often renamed to `pd`:\n\n\n\n::: {.cell filename='Python script'}\n\n```{.python .cell-code}\nimport pandas as pd\nDataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})\n```\n:::\n\n\nAlternatively, you can choose to import only the functions you want to use from a package:\n\n\n::: {.cell filename='Python script'}\n\n```{.python .cell-code}\nfrom pandas import DataFrame\nDataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})\n```\n:::\n\n\n\n## object-oriented programming\n\nI wish I had enough time to cover object-oriented programming (OOP) in depth,\nbut we're only going to scratch the surface.\n\nEverything in Python is an object. This is also true in R.\nYou can find out what class an object belongs to in Python with `type()`:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnumbers = [1,2,3,4]\ntype(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'list'>\n```\n:::\n\n```{.python .cell-code}\nname = \"Kelly\"\ntype(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n```\n:::\n\n```{.python .cell-code}\ntype(name) == str\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nor in R with `class()`:\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nclass(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(list(1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nname <- \"Kelly\"\nclass(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(name) == 'character'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n#### Objects of different classes have different methods and attributes.\n\n- methods: functions that operate on an object.\n- attributes: metadata associated with an object.\n\n\nLists have methods that can modify them in place\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4]\n```\n:::\n\n```{.python .cell-code}\nnumbers.append(5)\nnumbers.reverse()\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\nYou can split a string into a list based on a separator character with `split()`:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nfilename = \"path/to/file.txt\"\nfilename.split('.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['path/to/file', 'txt']\n```\n:::\n\n```{.python .cell-code}\nfilename.split('.')[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'path/to/file'\n```\n:::\n:::\n\n\nUse `join()` to do the opposite of `split()`:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\ncolumn_names = ['patient_id', 'sample_id', 'collection_date']\n','.join(column_names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'patient_id,sample_id,collection_date'\n```\n:::\n:::\n\n\nYou can even define your own classes! Use the `class` keyword and define `__init__` -- the function that _initializes_ a new instance of the class.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def is_good(self):\n        return True\n```\n:::\n\n\n`name` is an attribute of the Dog class. `is_good()` is a method of the Dog class.\nCreate a new instance of the `Dog` class and try using it:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfido = Dog('fido')\nprint(fido.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfido\n```\n:::\n\n```{.python .cell-code}\nprint(fido.is_good())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n\nTODO explain how this works in Snakemake input/output/params etc\n\nTake advantage of object-oriented programming to DRY your code by referencing \noutput files from other rules.\n\n\n<!--\n## reading & writing files\n\nTODO\n-->",
    "supporting": [
      "just-a-little-more-python_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}