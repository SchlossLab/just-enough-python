{
  "hash": "1740e7d754d57bb54ef69d434abc9c1d",
  "result": {
    "markdown": "---\ntitle: \"Just Enough Python\"\nsubtitle: \"for R users to write advanced Snakemake workflows\"\ndate: 2022-11-14\ndate-modified: 2022-11-21\naliases: \n    - just-enough-python.html\nengine: knitr\n---\n\n::: {.cell}\n\n:::\n\n\n\nSnakemake is a workflow management tool implemented as extra magic on top of Python. \nIf you want to take your Snakemake workflows from beginner to advanced, \nlearning a little Python goes a long way.\n\nThis is just enough Python to understand and apply some cool tricks in your Snakemake workflows.\n\n![](/images/python-snakemake-r-logos-horiz.png){ width=300px fig-align=\"center\" fig-alt=\"The Python, R, and Snakemake logos linked together.\"}^[The [Python logo](https://commons.wikimedia.org/wiki/File:Python-logo-notext.svg) by the Python Software Foundation is licensed under GNU GPL v2. The [Snakemake logo](https://commons.wikimedia.org/wiki/File:Snakemake_logo_dark.png) by Johannes Köster is  licensed under CC BY-SA 4.0. The [R logo](https://commons.wikimedia.org/wiki/File:R_logo.svg) by Hadley Wickham and others at RStudio is licensed under CC BY-SA 4.0.]\n\n#####  prereqs\n\n- **Basic Snakemake knowledge.** You've gone through [the official tutorial](https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html). \n  Maybe you've even built your own snakemake workflow.\n- Minimal or **no python knowledge**, aside from what you may have gleaned from \n  the snakemake docs.\n- **Basic R knowledge.** Tidyverse experience is helpful but not required.\n\n\n## variables\n\nHere are the basic variable types in Python and the equivalent type in R:\n\n### basic types\n\n| Python  | R         |\n|---------|-----------|\n| string  | character |\n| integer | integer   |\n| float   | numeric   |\n| boolean | logical   |\n| None    | NULL      |\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\n# string\nname = \"Kelly\"\nfavorite_color = 'green'\n# float\nheight_inches = 64.0\n# int\nnum_plants = 14\n# bool\nlikes_cats = True\n# none\ninvalid = None\n```\n:::\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\n# character\nname <- \"Kelly\"\nfavorite_color <- 'green'\n# numeric\nheight_inches <- 64\n# integer\nnum_plants <- 14L\n# logical\nlikes_cats <- TRUE\n# null\ninvalid = NULL\n```\n:::\n\n\nA key difference is that in R, all of the above objects are **vectors** of length 1.\n\n#### type casting\n\nYou can convert variables to different types:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nint(32.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n32\n```\n:::\n\n```{.python .cell-code}\nfloat(32)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n32.0\n```\n:::\n\n```{.python .cell-code}\nstr(32)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'32'\n```\n:::\n\n```{.python .cell-code}\nbool(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n\n```{.python .cell-code}\nbool(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n\n```{.python .cell-code}\nbool(None)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\nThe equivalent R code:\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nas.integer(32)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32\n```\n:::\n\n```{.r .cell-code}\nas.numeric(32L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32\n```\n:::\n\n```{.r .cell-code}\nas.character(32)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"32\"\n```\n:::\n\n```{.r .cell-code}\nas.logical(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nas.logical(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlogical(0)\n```\n:::\n:::\n\n\nWhat similarities and differences do you notice when type-casting in Python vs. R?\n\n#### Naming variables\n\nThe biggest difference in variable names between R and Python: \nno dots are allowed in Python variable names. \nAll other rules from R apply. Python variable names must start \nwith an alphabetic character and they can contain alphanumeric characters \nand underscores.\n\nJust like in R, it is a good idea not to name a variable the same thing as a \nreserved keyword or global function.\n\n\n::: {.cell filename='Python keywords'}\n\n```{.python .cell-code}\nhelp(\"keywords\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               break               for                 not\nNone                class               from                or\nTrue                continue            global              pass\n__peg_parser__      def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\n```\n:::\n:::\n\n\n#### formatting strings\n\nYou can add strings together to build new ones like this:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nfirstname = \"Marie\"\nlastname = \"Curie\"\nmiddle_init = 'S'\nprefix = \"Madame\"\n\nfullname = prefix + \" \" + firstname + \" \" + middle_init + \". \" + lastname\nprint(fullname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMadame Marie S. Curie\n```\n:::\n:::\n\n\nThe print function takes any number of arguments and will insert a space between\nitems by default:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nprint(prefix, firstname, middle_init + \".\", lastname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMadame Marie S. Curie\n```\n:::\n:::\n\n\nBut there's a better way!\n\n**f-Strings** in Python work just like `glue()` in R, where curly braces in the \nstring are interpreted as code. They're much easier to read & write:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nf\"{prefix} {firstname} {middle_init}. {lastname}\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'Madame Marie S. Curie'\n```\n:::\n:::\n\n\nThis is equivalent to:\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nfirstname <- \"Marie\"\nlastname <- \"Curie\"\nmiddle_init <- 'S'\nprefix <- \"Madame\"\nglue::glue(\"{prefix} {firstname} {middle_init}. {lastname}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMadame Marie S. Curie\n```\n:::\n:::\n\n\n\n### container types\n\nHere are a few of the most useful container types and their equivalents in R:\n\n| Python             | R              |\n|--------------------|----------------|\n| list               | vector (all same type) or list (multiple types) |\n| dictionary         | named list     |\n| DataFrame (pandas) | data.frame (base) or tibble (tidyverse) |\n\n#### lists\n\nPython lists are most similar to lists in R. Python lists can also be compared\nto vectors in R, but unlike vectors, lists can contain objects of different types.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nfruit = ['apple','banana','grape']\nmy_list = ['pizza', 'fries', 3, -2.5, 'donuts']\nfruit + my_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['apple', 'banana', 'grape', 'pizza', 'fries', 3, -2.5, 'donuts']\n```\n:::\n\n```{.python .cell-code}\nfruit.append('mango')\nfruit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['apple', 'banana', 'grape', 'mango']\n```\n:::\n:::\n\n\n##### Indexing\n\nIndexing is 0-based in Python. You can index lists and strings. \n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnumbers = [1,2,3,4]\nlen(numbers) # length\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n\n```{.python .cell-code}\nnumbers[0] # first item\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n\n```{.python .cell-code}\nnumbers[3] # last item\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n\n```{.python .cell-code}\nnumbers[-1] # last item\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n\nYou might find 0-based indexing unintuitive if you're used to working in \nlanguages like R that use 1-based indexing, but this is \n\"not mad, just differently sane!\"^[Greg Wilson quoting Terry Pratchett in \n_The Tidynomicon_: <https://tidynomicon.github.io/tidynomicon/>]\n\nHere's an illustration that shows how 0-based & 1-based indexing systems compare\nin the context of DNA coordinates^[from biostars: <https://www.biostars.org/p/84686/>]:\n\n[![DNA indexing comparison](https://i.postimg.cc/yxxngrS5/single-nucleotide-or-variant.jpg)](https://www.biostars.org/p/84686/)\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\ndna = \"TACGTCA\"\nprint(dna[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nT\n```\n:::\n\n```{.python .cell-code}\nprint(dna[6])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA\n```\n:::\n:::\n\n\nWe can try to write equivalent code in R...\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\ndna <- \"TACGTCA\"\nprint(dna[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"TACGTCA\"\n```\n:::\n\n```{.r .cell-code}\nprint(dna[7])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nBut this doesn't work! \nIn the above R code, `dna` is a vector of length 1 with \"TACGTCA\" as the item at index 1.\nYou can't grab individual characters out of it.\nWe have to break up the string into a vector with every character as a separate item in R.\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\ndna <- c('T', 'A', 'C', 'G', 'T', 'C', 'A')\nprint(dna[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"T\"\n```\n:::\n\n```{.r .cell-code}\nprint(dna[[7]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\"\n```\n:::\n:::\n\n\n\n#### dictionaries\n\nDictionaries consist of key-value pairs where you use the key to access the value.\nKeys can be strings, integers, floats, or booleans. Values can be anything!\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nfoods = {'vegetable': ['carrot', 'eggplant'], \n         'fruit': 'cherry'}\nfoods['fruit']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'cherry'\n```\n:::\n\n```{.python .cell-code}\nfoods['vegetable']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['carrot', 'eggplant']\n```\n:::\n\n```{.python .cell-code}\nfoods['vegetable'][0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'carrot'\n```\n:::\n:::\n\n\nDictionaries can be nested:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nhyperparams = {'glmnet': {'alpha': [0, 0.5, 1],\n                          'lambda': [0.01, 0.1, 0, 1]\n                          },\n                'rf': {'mtry': [128, 256, 512]}\n               }\nhyperparams['glmnet']['alpha'][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.5\n```\n:::\n:::\n\n\nGet a list of keys in the dictionary with:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nhyperparams.keys()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_keys(['glmnet', 'rf'])\n```\n:::\n:::\n\n\n##### Snakemake config\n\nSay you have a Snakemake workflow for training machine learning models.\nYou want to be able to specify different datasets, ML methods, and random seeds, \nso you use f-Strings to fill in these variables:\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\ndataset = \"OTU\"\nmethod = \"rf\"\nseed = 1001\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=f\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n```\n:::\n\n\nYou can improve this by creating a configuration file in YAML format:\n\n\n::: {.cell filename='config/otu.yml'}\n\n```{.r .cell-code}\ndataset: 'OTU'\nmethod: 'rf'\nseed: 1001\n```\n:::\n\n\nThen specify your config file at the top of your Snakefile.\nSnakemake parses your YAML config files to a dictionary called `config`.\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\nconfigfile: \"config/otu.yml\"\n\ndataset = config[\"dataset\"]\nmethod = config['rf']\nseed = config['seed']\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=f\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n```\n:::\n\n\n\nWhen you run this workflow, it uses `config/otu.yml` by default:\n\n\n::: {.cell filename='sh'}\n\n```{.bash .cell-code}\nsnakemake -n\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nrule train_ml_model:\n    input: workflow/scripts/train_ml.R, data/OTU.csv\n    output: results/OTU/runs/rf_1001_model.Rds\n    jobid: 0\n    reason: Missing output files: results/OTU/runs/rf_1001_model.Rds\n    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T\n\nJob stats:\njob               count    min threads    max threads\n--------------  -------  -------------  -------------\ntrain_ml_model        1              1              1\ntotal                 1              1              1\n```\n:::\n\n\n\nNow you can change the values of these variables by editing the config file,\nor by creating multiple config files and specifying them on the command line:\n\n\n::: {.cell filename='config/genus.yml'}\n\n```{.r .cell-code}\ndataset: 'genus'\nmethod: 'glmnet'\nseed: 1001\n```\n:::\n\n::: {.cell filename='sh'}\n\n```{.bash .cell-code}\nsnakemake -n --configfile config/genus.yml\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nrule train_ml_model:\n    input: workflow/scripts/train_ml.R, data/genus.csv\n    output: results/genus/runs/glmnet_1001_model.Rds\n    jobid: 0\n    reason: Missing output files: results/genus/runs/glmnet_1001_model.Rds\n    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T\n\nJob stats:\njob               count    min threads    max threads\n--------------  -------  -------------  -------------\ntrain_ml_model        1              1              1\ntotal                 1              1              1\n```\n:::\n\n\n\nSee this example in context [here](https://github.com/SchlossLab/just-enough-python/blob/main/Snakemake_demo/workflow/Snakefile).\n\n## conditionals\n\nThink of these as functions that return a boolean.\n\n| operator | meaning                  | same in R |\n|----------|--------------------------|-----------|\n| `==`     | equal                    | ✅        |\n| `!=`     | not equal                | ✅        |\n| `<`      | less than                | ✅        |\n| `>`      | greater than             | ✅        |\n| `<=`     | less than or equal to    | ✅        |\n| `>=`     | greater than or equal to | ✅        |\n| or       | or (inclusive)           | `|`       |\n| and      | and                      | `&`       |\n| in       | in                       | `%in%`    |\n| not      | not                      | `!`       |\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 > 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n\n```{.python .cell-code}\nTrue or False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n### if-else statements\n\nNo curly braces here! But indentation does matter.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nif len(my_list) < 10:\n    list_description = \"This list is short\"\nelif len(my_list) < 15:\n    list_description = \"This list is medium length\"\nelse:\n    list_description = \"This list is long!\"\nprint(list_description)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis list is short\n```\n:::\n:::\n\n\n#### inline if-else statement\n\nWhen you create a variable with an if-else statement, \nyou can do it all on one line:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist_description = \"short\" if len(my_list) < 10 else \"not short\"\n```\n:::\n\n\nThis is equivalent to:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nif len(my_list) < 10:\n    list_description = \"short\"\nelse:\n    list_description = \"not short\"\n```\n:::\n\n\nYou can't make it a one-liner if you need to use `elif`.\n\n#### nested if-else blocks\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnum = 1\nif num >= 0:\n    if num == 0:\n        print(\"zero\")\n    else:\n        print(\"positive\")\nelse:\n    print(\"negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npositive\n```\n:::\n:::\n\n\n\n## for loops\n\nIf a variable has a length (i.e. you can run `len(myvar)`), then you can \n**iterate** over it in a for loop.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\npostdocs = ['Allison Mason', 'Courtney Armour', 'Sarah Lucas']\nfor person in postdocs:\n    print(f\"{person}, PhD\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAllison Mason, PhD\nCourtney Armour, PhD\nSarah Lucas, PhD\n```\n:::\n:::\n\n\n### range\n\nUse `range()` to loop over a range of numbers. If you give `range()` two arguments,\nrange starts counting from the first argument and stops _just before_ the second argument,\nstepping by 1.\nIn other words, the stop argument is _exclusive_.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnum_bottles = 3\nfor i in range(1, num_bottles+1):\n    print(i, \" bottles of pop on the wall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1  bottles of pop on the wall\n2  bottles of pop on the wall\n3  bottles of pop on the wall\n```\n:::\n:::\n\n\nIf you give range just one argument, it starts counting from zero and uses\nthe argument as the stop value:\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnum_bottles = 3\nfor i in range(num_bottles+1):\n    print(i, \" bottles of pop on the wall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0  bottles of pop on the wall\n1  bottles of pop on the wall\n2  bottles of pop on the wall\n3  bottles of pop on the wall\n```\n:::\n:::\n\n\n<!-- made it to here in code club #1 -->\n\nYou can also use `range()` to create lists:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nmylist = list(range(3))\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2]\n```\n:::\n:::\n\n\nYou can use range with three arguments: `start`, `stop`, and `step`:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nlist(range(2, 11, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 6, 8, 10]\n```\n:::\n:::\n\n\nGive the `step` argument a negative value and make `start` greater than `stop` to move backwards:\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nlist(range(4, -7, -2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 2, 0, -2, -4, -6]\n```\n:::\n:::\n\n\nYou might think it's weird that range stops just _before_ the stop value.\nBut it works nicely when you give it the length of the list -- now you have the list indices!\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nnumbers = [1,2,3,4]\nfor i in range(len(numbers)):\n    print(f\"index {i} is {numbers[i]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nindex 0 is 1\nindex 1 is 2\nindex 2 is 3\nindex 3 is 4\n```\n:::\n:::\n\n\n\n### iterate over dictionaries\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nproblems = {1: \"naming things\", 2: \"understanding binary\", 3: \"off-by-one errors\"}\nprint('There are only 10 hard problems in computer science:')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are only 10 hard problems in computer science:\n```\n:::\n\n```{.python .cell-code}\nfor num in problems:\n    print(f\"\\t {num} {problems[num]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\t 1 naming things\n\t 2 understanding binary\n\t 3 off-by-one errors\n```\n:::\n:::\n\n\n\n### list comprehensions\n\nWhen you want to make a for loop that creates a new list, dictionary, or set,\nuse a **comprehension**. I'm only going to cover list comprehensions below,\nbut you can learn about dictionary and set comprehensions \n[here](just-a-little-more-python.qmd#more-comprehensions).\n\nTo build a list with a for loop, you can do this:\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nsquares = []\nfor i in range(4):\n    squares.append(i**2)\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 4, 9]\n```\n:::\n:::\n\n\nbut a **list comprehension** is much sleeker and performs faster:\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nsquares = [i**2 for i in range(4)]\n```\n:::\n\n\nThis is roughly equivalent to using *apply functions in R:\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nsapply(0:3, function(x) {x**2})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 4 9\n```\n:::\n:::\n\n\nYou can continue nesting `for x in y` statements to build complex lists like this:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\n[f\"{x}{y}{z}\" for x in range(1,3) for y in range(2,4) for z in range(3,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['123', '124', '133', '134', '223', '224', '233', '234']\n```\n:::\n:::\n\n\n#### Snakemake expand\n\nLet's say you have a Snakemake workflow with a rule that should run multiple times\nwith different parameters. For example, you may want to train machine learning models\nwith different ML methods, datasets, and random seeds. \nYou define these as [wildcards](https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#wildcards) in a rule to train each ML model:\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=\"data/{dataset}.csv\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n```\n:::\n\n\nNotice that we're _not_ using **f-Strings** within the rule because we want \nSnakemake to recognize these as **wildcards** and fill in different values for\nthem with each run of the `train_ml_model` rule.\n\nTo tell Snakemake what values to assign for these wildcards, you can create \nlists with the values you want and write a target rule at the top of your Snakefile.\n\nHere, you could use an f-String and a list comprehension to create the list of target files.\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n[f\"results/{dataset}/runs/{method}_{seed}_model.Rds\" for dataset in datasets for method in methods for seed in seeds]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['results/OTU/runs/rf_1000_model.Rds', 'results/OTU/runs/rf_1001_model.Rds', 'results/OTU/runs/rf_1002_model.Rds', 'results/OTU/runs/rf_1003_model.Rds', 'results/OTU/runs/rf_1004_model.Rds', 'results/OTU/runs/glmnet_1000_model.Rds', 'results/OTU/runs/glmnet_1001_model.Rds', 'results/OTU/runs/glmnet_1002_model.Rds', 'results/OTU/runs/glmnet_1003_model.Rds', 'results/OTU/runs/glmnet_1004_model.Rds', 'results/OTU/runs/svmRadial_1000_model.Rds', 'results/OTU/runs/svmRadial_1001_model.Rds', 'results/OTU/runs/svmRadial_1002_model.Rds', 'results/OTU/runs/svmRadial_1003_model.Rds', 'results/OTU/runs/svmRadial_1004_model.Rds', 'results/genus/runs/rf_1000_model.Rds', 'results/genus/runs/rf_1001_model.Rds', 'results/genus/runs/rf_1002_model.Rds', 'results/genus/runs/rf_1003_model.Rds', 'results/genus/runs/rf_1004_model.Rds', 'results/genus/runs/glmnet_1000_model.Rds', 'results/genus/runs/glmnet_1001_model.Rds', 'results/genus/runs/glmnet_1002_model.Rds', 'results/genus/runs/glmnet_1003_model.Rds', 'results/genus/runs/glmnet_1004_model.Rds', 'results/genus/runs/svmRadial_1000_model.Rds', 'results/genus/runs/svmRadial_1001_model.Rds', 'results/genus/runs/svmRadial_1002_model.Rds', 'results/genus/runs/svmRadial_1003_model.Rds', 'results/genus/runs/svmRadial_1004_model.Rds']\n```\n:::\n:::\n\n\nHere's what your Snakefile looks like now.\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n\nrule targets:\n    input:\n        [f\"results/{dataset}/runs/{method}_{seed}_model.Rds\" for dataset in datasets for method in methods for seed in seeds]\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n```\n:::\n\n\nThe list comprehension gets harder to read the more `for` statements you add to it.\nSo Snakemake provides a function `expand()` to clean this up:\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n\nrule targets:\n    input:\n        expand(\"results/{dataset}/runs/{method}_{seed}_model.Rds\", \n                dataset = datasets, method = methods, seed = seeds)\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n```\n:::\n\n\nUsing `expand()` creates the exact same list as the list comprehension, but it's\nmuch easier to read and add variables to.\n\n\n## functions\n\nYou can define your own functions\nin R: \n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nsquare <- function(x) {\n    return(x^2)\n}\n\nsquare(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nand in Python:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\ndef square(x):\n    return x**2\n\nsquare(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n\n### anonymous functions\n\nSometimes you want to write a simple function that you only use once.\nThey're so inconsequential you don't even want to give them a name.\n\nWe've already used one in R^[Read more about anonymous functions in Hadley Wickham's book _Advanced R_: <http://adv-r.had.co.nz/Functional-programming.html#anonymous-functions>] inside `sapply()` above:\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nfunction(x) { x**2 }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(x) { x**2 }\n```\n:::\n:::\n\n\n\nIn Python you use the `lambda` keyword:\n\n\n::: {.cell filename='Python'}\n\n```{.python .cell-code}\nlambda x: x**2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<function <lambda> at 0x105230af0>\n```\n:::\n:::\n\n\nBefore the colon, list the arguments of the function.\nAfter the colon, compute the value that the function should return.\n\n#### lambda in Snakemake\n\nWhen writing Snakemake workflows, lambda functions are useful for defining input \nfiles based on the wildcards in output files.\nConsider a workflow where you have several rules that plot figures for a manuscript.\nWhen you initially conduct the analysis, you don't know how the figures will be ordered\nin the manuscript.\nOnce you begin drafting the manuscript, you decide that your diversity plot will\nbe figure 1 and your error rates plot will be figure 2.\nYou also decide to convert the figures to a different format, so the conversion\nstep seems like a good opportunity to rename the figures.\nInitially you write this workflow:\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\nrule targets:\n    input:\n        \"paper/paper.pdf\"\n\nrule convert_figure_1:\n    input:\n        tiff='figures/diversity.tiff'\n    output:\n        png=\"paper/figure_1.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule convert_figure_2:\n    input:\n        tiff='figures/error_rates.tiff'\n    output:\n        png=\"paper/figure_2.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule render_paper:\n    input:\n        Rmd=\"paper/paper.Rmd\",\n        R=\"workflow/scripts/render_rmd.R\",\n        figures=['paper/figure_1.png', 'paper/figure_2.png']\n    output:\n        pdf=\"paper/paper.pdf\"\n    script:\n        \"scripts/render_rmd.R\"\n```\n:::\n\n\nThe rules `convert_figure_1` and `convert_figure_2` are a bit repetitive; they\nonly differ by the input filenames and the figure numbers in the output filenames.\nMaybe this isn't so bad with only two figures, but you might actually have 5-10 \nfigures for a full scientific paper. We can reduce the repetitive code with\na few tricks:\n\n1. Create a dictionary `figures_dict` that maps the figure numbers to the descriptive figure file names.\n1. Use a single rule to convert figures called `convert_tiff_to_png`, using a lambda function to get the input figure filenames based on the final figure numbers.\n\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\nfigures_dict = {'1': 'diversity', '2': 'error_rates'}\n\nrule targets:\n    input:\n        \"paper/paper.pdf\"\n\nrule convert_tiff_to_png:\n    input:\n        tiff=lambda wildcards: f\"figures/{figures_dict[wildcards.fig_num]}.tiff\"\n    output:\n        png=\"paper/figure_{fig_num}.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule render_paper:\n    input:\n        Rmd=\"paper/paper.Rmd\",\n        R=\"workflow/scripts/render_rmd.R\",\n        figures=['paper/figure_1.png', 'paper/figure_2.png']\n    output:\n        pdf=\"paper/paper.pdf\"\n    script:\n        \"scripts/render_rmd.R\"\n```\n:::\n\n\n\nThis lambda function is equivalent to:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_fig_name_from_num(wildcards):\n    return figures_dict[wildcards.fig_num]\n```\n:::\n\n\nThis works because Snakemake allows you to define a function that takes the \nrule's wildcards and returns a list of input filenames, rather than literally\nlisting the input filenames as before.\nThis greatly reduces the repetitiveness of the code and makes it easier to maintain.\n\nWe can improve this Snakefile even further by replacing the list of figures in\n`render_paper` with a call to `expand()`:\n\n\n::: {.cell filename='Snakefile'}\n\n```{.python .cell-code}\nfigures_dict = {'1': 'diversity', '2': 'error_rates'}\n\nrule targets:\n    input:\n        \"paper/paper.pdf\"\n\nrule convert_tiff_to_png:\n    input:\n        tiff=lambda wildcards: f\"figures/{figures_dict[wildcards.fig_num]}.tiff\"\n    output:\n        png=\"paper/figure_{fig_num}.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule render_paper:\n    input:\n        Rmd=\"paper/paper.Rmd\",\n        R=\"workflow/scripts/render_rmd.R\",\n        figures=expand(rules.convert_tiff_to_png.output.png, \n                       fig_num = figures_dict.keys())\n    output:\n        pdf=\"paper/paper.pdf\"\n    script:\n        \"scripts/render_rmd.R\"\n```\n:::\n\n\n\nYou can take a look at this full example in context [here](https://github.com/kelly-sovacool/figure-convert-reprex).\nAlso see the Snakemake docs for more about [input functions](https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#snakefiles-input-functions)\nand [params functions](https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#non-file-parameters-for-rules).\n\n\n# recap\n\n**Snakemake concepts covered**\n\n- Use [**f-Strings**](#formatting-strings) for human-readable string formatting.\n- [**Config files**](#snakemake-config) are imported as dictionaries and allow you to change workflow parameters without modifying code.\n- Snakemake's [**expand()**](#snakemake-expand) function is a readable way to build lists just like list comprehensions.\n- [**Lambda functions**](#lambda-in-snakemake) help define Snakemake input files based on wildcards. You can also use them to define params based on wildcards and/or output files.\n\n# resources {.appendix}\n\n- [The Python docs](https://docs.python.org/3/)\n- [The Snakemake docs](https://snakemake.readthedocs.io/)\n<!--\n- [Just A Little More Python](just-a-little-more-python.qmd): topics I wish I had time to cover in this tutorial.\n-->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}