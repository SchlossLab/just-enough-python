[
  {
    "objectID": "just-a-little-more-python.html",
    "href": "just-a-little-more-python.html",
    "title": "Just A Little More Python",
    "section": "",
    "text": "I wish I had time to cover everything in-depth, but then I’d have to change the title from “Just Enough Python” to “Way More Python Than We Could Possibly Cover In An Hour”. So as a compromise, here’s just a little more Python."
  },
  {
    "objectID": "just-a-little-more-python.html#packages",
    "href": "just-a-little-more-python.html#packages",
    "title": "Just A Little More Python",
    "section": "packages",
    "text": "packages\nUsing packages works a little differently between R and Python.\nIn R, you can refer to a function from any package you have installed with double colons:\n\n\n\nR script\n\ndplyr::tibble(a = 1:3, b = 4:6)\n\n\nAlternatively, you can first load the package at the top of your script so you can call the functions you want to use without specifying the package name every time you use them.\n\n\n\nR script\n\nlibrary(dplyr)\ntibble(a = 1:5, b = 6:10) %>%\n    filter(a > 3)\n\n\nIn Python, you must import a package before you can use anything from it and reference the package name like this:\n\n\n\nPython script\n\nimport pandas\npandas.DataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})\n\n\nYou can give a package a nickname to cut down on the characters you have to type. pandas is often renamed to pd:\n\n\n\nPython script\n\nimport pandas as pd\nDataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})\n\n\nAlternatively, you can choose to import only the functions you want to use from a package:\n\n\n\nPython script\n\nfrom pandas import DataFrame\nDataFrame(data = {'a': [1,2,3], 'b': [4,5,6]})"
  },
  {
    "objectID": "just-a-little-more-python.html#object-oriented-programming",
    "href": "just-a-little-more-python.html#object-oriented-programming",
    "title": "Just A Little More Python",
    "section": "object-oriented programming",
    "text": "object-oriented programming\nI wish I had enough time to cover object-oriented programming (OOP) in depth, but we’re only going to scratch the surface.\nEverything in Python is an object. This is also true in R. You can find out what class an object belongs to in Python with type():\n\n\n\nPython\n\nnumbers = [1,2,3,4]\ntype(numbers)\n\n\n<class 'list'>\n\nname = \"Kelly\"\ntype(name)\n\n<class 'str'>\n\ntype(name) == str\n\nTrue\n\n\nor in R with class():\n\n\n\nR\n\nclass(1:3)\n\n\n[1] \"integer\"\n\nclass(list(1, 2, 3))\n\n[1] \"list\"\n\nname <- \"Kelly\"\nclass(name)\n\n[1] \"character\"\n\nclass(name) == 'character'\n\n[1] TRUE\n\n\nObjects of different classes have different methods and attributes.\n\nmethods: functions that operate on an object.\nattributes: metadata associated with an object.\n\nLists have methods that can modify them in place\n\n\n\nPython\n\nprint(numbers)\n\n\n[1, 2, 3, 4]\n\nnumbers.append(5)\nnumbers.reverse()\nprint(numbers)\n\n[5, 4, 3, 2, 1]\n\n\nYou can split a string into a list based on a separator character with split():\n\n\n\nPython\n\nfilename = \"path/to/file.txt\"\nfilename.split('.')\n\n\n['path/to/file', 'txt']\n\nfilename.split('.')[0]\n\n'path/to/file'\n\n\nUse join() to do the opposite of split():\n\n\n\nPython\n\ncolumn_names = ['patient_id', 'sample_id', 'collection_date']\n','.join(column_names)\n\n\n'patient_id,sample_id,collection_date'\n\n\nYou can even define your own classes! Use the class keyword and define __init__ – the function that initializes a new instance of the class.\n\n\n\nPython\n\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def is_good(self):\n        return True\n\n\nname is an attribute of the Dog class. is_good() is a method of the Dog class. Create a new instance of the Dog class and try using it:\n\nfido = Dog('fido')\nprint(fido.name)\n\nfido\n\nprint(fido.is_good())\n\nTrue\n\n\nTODO explain how this works in Snakemake input/output/params etc\nTake advantage of object-oriented programming to DRY your code by referencing output files from other rules."
  },
  {
    "objectID": "just-enough-python.html",
    "href": "just-enough-python.html",
    "title": "Just Enough Python",
    "section": "",
    "text": "Snakemake is a workflow management tool implemented as extra magic on top of Python. If you want to take your Snakemake workflows from beginner to advanced, learning a little Python goes a long way.\nThis is just enough Python to understand and apply some cool tricks in your Snakemake workflows."
  },
  {
    "objectID": "just-enough-python.html#variables",
    "href": "just-enough-python.html#variables",
    "title": "Just Enough Python",
    "section": "variables",
    "text": "variables\nbasic types\n\n\nPython\nR\n\n\n\nstring\ncharacter\n\n\ninteger\ninteger\n\n\nfloat\nnumeric\n\n\nboolean\nlogical\n\n\nNone\nNULL\n\n\n\n\n\n\nPython\n\n# string\nname = \"Kelly\"\nfavorite_color = 'green'\n# float\nheight_inches = 64.0\n# int\nnum_plants = 14\n# bool\nlikes_cats = True\n# none\ninvalid = None\n\n\n\n\n\nR\n\n# character\nname <- \"Kelly\"\nfavorite_color <- 'green'\n# numeric\nheight_inches <- 64\n# integer\nnum_plants <- 14L\n# logical\nlikes_cats <- TRUE\n# null\ninvalid = NULL\n\n\nA key difference is that in R, all of the above objects are vectors of length 1.\ntype casting\n\n\n\nPython\n\nint(32.0)\n\n\n32\n\nfloat(32)\n\n32.0\n\nstr(32)\n\n'32'\n\nbool(0)\n\nFalse\n\nbool(1)\n\nTrue\n\nbool(None)\n\nFalse\n\n\nNaming variables\nBiggest difference between R and Python: no dots are allowed in Python variable names. All other rules from R apply. Python variable names must start with an alphabetic character and they can contain alphanumeric characters and underscores.\nJust like in R, it is a good idea not to name a variable the same thing as a reserved keyword or global function.\n\n\n\nPython keywords\n\nhelp(\"keywords\")\n\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               break               for                 not\nNone                class               from                or\nTrue                continue            global              pass\n__peg_parser__      def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\n\n\nformatting strings\nYou can add strings together to build new ones like this:\n\n\n\nPython\n\nfirstname = \"Marie\"\nlastname = \"Curie\"\nmiddle_init = 'S'\nprefix = \"Madame\"\n\nfullname = prefix + \" \" + firstname + \" \" + middle_init + \". \" + lastname\nprint(fullname)\n\n\nMadame Marie S. Curie\n\n\nThe print function takes any number of arguments and will insert a space between items by default:\n\n\n\nPython\n\nprint(prefix, firstname, middle_init + \".\", lastname)\n\n\nMadame Marie S. Curie\n\n\nBut there’s a better way!\nf-Strings in Python work just like glue() in R, where curly braces in the string are interpreted as code. They’re much easier to read & write:\n\n\n\nPython\n\nf\"{prefix} {firstname} {middle_init}. {lastname}\"\n\n\n'Madame Marie S. Curie'\n\n\nThis is equivalent to:\n\n\n\nR\n\nfirstname <- \"Marie\"\nlastname <- \"Curie\"\nmiddle_init <- 'S'\nprefix <- \"Madame\"\nglue::glue(\"{prefix} {firstname} {middle_init}. {lastname}\")\n\n\nMadame Marie S. Curie\n\n\ncontainer types\n\n\nPython\nR\n\n\n\nlist\nvector (all same type) or list (multiple types)\n\n\ndictionary\nnamed list\n\n\ndataframe (pandas)\ndataframe (base) or tibble (tidyverse)\n\n\n\nlists\nPython lists are most similar to lists in R. Python lists can also be compared to vectors in R, but unlike vectors, lists can contain objects of different types.\n\n\n\nPython\n\nfruit = ['apple','banana','grape']\nmy_list = ['pizza', 'fries', 3, -2.5, 'donuts']\nfruit + my_list\n\n\n['apple', 'banana', 'grape', 'pizza', 'fries', 3, -2.5, 'donuts']\n\nfruit.append('mango')\nfruit\n\n['apple', 'banana', 'grape', 'mango']\n\n\nIndexing\nIndexing is 0-based in Python. You can index lists and strings.\n\n\n\nPython\n\nnumbers = [1,2,3,4]\nlen(numbers) # length\n\n\n4\n\nnumbers[0] # first item\n\n1\n\nnumbers[3] # last item\n\n4\n\nnumbers[-1] # last item\n\n4\n\n\nYou might find 0-based indexing unintuitive if you’re used to working in languages like R that use 1-based indexing, but:\n\n\n[this is] not mad, just differently sane! - Terry Pratchett - Greg Wilson[^From The Tidynomicon by Greg Wilson: https://tidynomicon.github.io/tidynomicon/]\n\n\nHere’s an illustration that shows how 0-based & 1-based indexing systems compare in the context of DNA coordinates1:\n\n\nDNA indexing comparison\n\n\n\n\n\nPython\n\ndna = \"TACGTCA\"\nprint(dna[0])\n\n\nT\n\nprint(dna[6])\n\nA\n\n\nWe can try to write equivalent code in R…\n\n\n\nR\n\ndna <- \"TACGTCA\"\nprint(dna[1])\n\n\n[1] \"TACGTCA\"\n\nprint(dna[7])\n\n[1] NA\n\n\nBut this doesn’t work! In the above R code, dna is a vector of length 1 with “TACGTCA” as the item at index 1. You can’t grab individual characters out of it. We have to break up the string into a vector with every character as a separate item in R.\n\n\n\nR\n\ndna <- c('T', 'A', 'C', 'G', 'T', 'C', 'A')\nprint(dna[[1]])\n\n\n[1] \"T\"\n\nprint(dna[[7]])\n\n[1] \"A\"\n\n\ndictionaries\nDictionaries consist of key-value pairs where you use the key to access the value. Keys can be strings, integers, floats, or booleans. Values can be anything!\n\n\n\nPython\n\nfoods = {'vegetable': ['carrot', 'eggplant'], \n         'fruit': 'cherry'}\nfoods['fruit']\n\n\n'cherry'\n\nfoods['vegetable']\n\n['carrot', 'eggplant']\n\nfoods['vegetable'][0]\n\n'carrot'\n\n\nDictionaries can be nested:\n\n\n\nPython\n\nhyperparams = {'glmnet': {'alpha': [0, 0.5, 1],\n                          'lambda': [0.01, 0.1, 0, 1]\n                          },\n                'rf': {'mtry': [128, 256, 512]}\n               }\nhyperparams['glmnet']['alpha'][1]\n\n\n0.5\n\n\nSnakemake config\nSay you have a Snakemake workflow for training machine learning models. You want to be able to specify different datasets, ML methods, and random seeds, so you use f-Strings to fill in these variables:\n\n\n\nSnakefile\n\ndataset = \"OTU\"\nmethod = \"rf\"\nseed = 1001\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=f\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n\n\nYou can improve this by creating a configuration file in YAML format:\n\n\n\nconfig/otu.yml\n\ndataset: 'OTU'\nmethod: 'rf'\nseed: 1001\n\n\nThen specify your config file at the top of your Snakefile. Snakemake parses your YAML config files to a dictionary called config.\n\n\n\nSnakefile\n\nconfigfile: \"config/otu.yml\"\n\ndataset = config[\"dataset\"]\nmethod = config['rf']\nseed = config['seed']\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=f\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n\n\nWhen you run this workflow, it uses config/otu.yml by default:\n\n\n\nsh\n\nsnakemake -n\n\n\n\nrule train_ml_model:\n    input: workflow/scripts/train_ml.R, data/OTU.csv\n    output: results/OTU/runs/rf_1001_model.Rds\n    jobid: 0\n    reason: Missing output files: results/OTU/runs/rf_1001_model.Rds\n    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T\n\nJob stats:\njob               count    min threads    max threads\n--------------  -------  -------------  -------------\ntrain_ml_model        1              1              1\ntotal                 1              1              1\n\nNow you can change the values of these variables by editing the config file, or by creating multiple config files and specifying them on the command line:\n\n\n\nconfig/genus.yml\n\ndataset: 'genus'\nmethod: 'glmnet'\nseed: 1001\n\n\n\n\n\nsh\n\nsnakemake -n --configfile config/genus.yml\n\n\n\nrule train_ml_model:\n    input: workflow/scripts/train_ml.R, data/genus.csv\n    output: results/genus/runs/glmnet_1001_model.Rds\n    jobid: 0\n    reason: Missing output files: results/genus/runs/glmnet_1001_model.Rds\n    resources: tmpdir=/var/folders/9n/glrhxtfx453gl68sc1gzq0mc0000gr/T\n\nJob stats:\njob               count    min threads    max threads\n--------------  -------  -------------  -------------\ntrain_ml_model        1              1              1\ntotal                 1              1              1\n\nSee this example in context here."
  },
  {
    "objectID": "just-enough-python.html#conditionals",
    "href": "just-enough-python.html#conditionals",
    "title": "Just Enough Python",
    "section": "conditionals",
    "text": "conditionals\nThink of these as functions that return a boolean.\n\n\noperator\nmeaning\nsame in R\n\n\n\n==\nequal\n✅\n\n\n!=\nnot equal\n✅\n\n\n<\nless than\n✅\n\n\n>\ngreater than\n✅\n\n\n<=\nless than or equal to\n✅\n\n\n>=\ngreater than or equal to\n✅\n\n\nor\nor (inclusive)\n|\n\n\nand\nand\n&\n\n\nin\nin\n%in%\n\n\nnot\nnot\n!\n\n\n\n\n3 > 2\n\nTrue\n\nTrue or False\n\nTrue\n\n\nif-else statements\nNo curly braces here! But indentation does matter.\n\n\n\nPython\n\nif len(my_list) < 10:\n    list_description = \"This list is short\"\nelif len(my_list) >= 10 and len(my_list) < 15:\n    list_description = \"This list is medium length\"\nelse:\n    list_description = \"This list is long!\"\nprint(list_description)\n\n\nThis list is short\n\n\ninline if-else statement\nWhen you create a variable with an if-else statement, you can do it all on one line:\n\nlist_description = \"short\" if len(my_list) < 10 else \"not short\"\n\nThis is equivalent to:\n\nif len(my_list) < 10:\n    list_description = \"short\"\nelse:\n    list_description = \"not short\"\n\nYou can’t make it a one-liner if you need to use elif.\nnested if-else blocks\n\n\n\nPython\n\nnum = 1\nif num >= 0:\n    if num == 0:\n        print(\"zero\")\n    else:\n        print(\"positive\")\nelse:\n    print(\"negative\")\n\n\npositive"
  },
  {
    "objectID": "just-enough-python.html#for-loops",
    "href": "just-enough-python.html#for-loops",
    "title": "Just Enough Python",
    "section": "for loops",
    "text": "for loops\nIf a variable has a length (i.e. you can run len(myvar)), then you can iterate over it in a for loop.\n\n\n\nPython\n\npostdocs = ['Allison Mason', 'Courtney Armour', 'Sarah Lucas']\nfor person in postdocs:\n    print(f\"{person}, PhD\")\n\n\nAllison Mason, PhD\nCourtney Armour, PhD\nSarah Lucas, PhD\n\n\nrange\nUse range() to loop over a range of numbers. If you give range() two arguments, range starts counting from the first argument and stops just before the second argument, stepping by 1. In other words, the stop argument is exclusive.\n\n\n\nPython\n\nnum_bottles = 3\nfor i in range(1, num_bottles+1):\n    print(i, \" bottles of pop on the wall\")\n\n\n1  bottles of pop on the wall\n2  bottles of pop on the wall\n3  bottles of pop on the wall\n\n\nIf you give range just one argument, it starts counting from zero and uses the argument as the stop value:\n\n\n\nPython\n\nnum_bottles = 3\nfor i in range(num_bottles+1):\n    print(i, \" bottles of pop on the wall\")\n\n\n0  bottles of pop on the wall\n1  bottles of pop on the wall\n2  bottles of pop on the wall\n3  bottles of pop on the wall\n\n\nYou can also use range() to create lists:\n\n\n\nPython\n\nmylist = list(range(3))\nmylist\n\n\n[0, 1, 2]\n\n\nYou can use range with three arguments: start, stop, and step:\n\n\n\nPython\n\nlist(range(2, 11, 2))\n\n\n[2, 4, 6, 8, 10]\n\n\nGive the step argument a negative value and make start greater than stop to move backwards:\n\n\n\nPython\n\nlist(range(4, -7, -2))\n\n\n[4, 2, 0, -2, -4, -6]\n\n\nYou might think it’s weird that range stops just before the stop value. But it works nicely when you give it the length of the list – now you have the list indices!\n\n\n\nPython\n\nnumbers = [1,2,3,4]\nfor i in range(len(numbers)):\n    print(f\"index {i} is {numbers[i]}\")\n\n\nindex 0 is 1\nindex 1 is 2\nindex 2 is 3\nindex 3 is 4\n\n\niterate over dictionaries\n\n\n\nPython\n\nproblems = {1: \"naming things\", 2: \"understanding binary\", 3: \"off-by-one errors\"}\nprint('There are only 10 hard problems in computer science:')\n\n\nThere are only 10 hard problems in computer science:\n\nfor num in problems:\n    print(\"\\t\", num, problems[num])\n\n     1 naming things\n     2 understanding binary\n     3 off-by-one errors\n\n\ncomprehensions\nWhen you want to make a for loop that creates a new list, dictionary, or set, use a comprehension. I’m only going to cover list comprehensions below, but you can learn about dictionary and set comprehensions here.\nlist comprehensions\nTo build a list with a for loop, you can do this\n\n\n\nPython\n\nsquares = []\nfor i in range(4):\n    squares.append(i**2)\nsquares\n\n\n[0, 1, 4, 9]\n\n\nbut a list comprehension is much sleeker and performs faster:\n\n\n\nPython\n\nsquares = [i**2 for i in range(4)]\n\n\nthis is roughly equivalent to using *apply functions in R:\n\n\n\nR\n\nsapply(0:3, function(x) {x**2})\n\n\n[1] 0 1 4 9\n\n\nSnakemake expand\nLet’s say you have a Snakemake workflow with a rule that should run multiple times with different parameters. For example, you may want to train machine learning models with different ML methods, datasets, and random seeds. You define these as wildcards in a rule to train each ML model:\n\n\n\nSnakefile\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=\"data/{dataset}.csv\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n\n\nNotice that we’re not using f-Strings within the rule because we want Snakemake to recognize these as wildcards and fill in different values for them with each run of the train_ml_model rule.\nTo tell Snakemake what values to assign for these wildcards, you can create lists with the values you want and write a target rule at the top of your Snakefile.\nHere, you could use an f-String and a list comprehension to create the list of target files.\n\n\n\nPython\n\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n[f\"results/{dataset}/runs/{method}_{seed}_model.Rds\" for dataset in datasets for method in methods for seed in seeds]\n\n\n['results/OTU/runs/rf_1000_model.Rds', 'results/OTU/runs/rf_1001_model.Rds', 'results/OTU/runs/rf_1002_model.Rds', 'results/OTU/runs/rf_1003_model.Rds', 'results/OTU/runs/rf_1004_model.Rds', 'results/OTU/runs/glmnet_1000_model.Rds', 'results/OTU/runs/glmnet_1001_model.Rds', 'results/OTU/runs/glmnet_1002_model.Rds', 'results/OTU/runs/glmnet_1003_model.Rds', 'results/OTU/runs/glmnet_1004_model.Rds', 'results/OTU/runs/svmRadial_1000_model.Rds', 'results/OTU/runs/svmRadial_1001_model.Rds', 'results/OTU/runs/svmRadial_1002_model.Rds', 'results/OTU/runs/svmRadial_1003_model.Rds', 'results/OTU/runs/svmRadial_1004_model.Rds', 'results/genus/runs/rf_1000_model.Rds', 'results/genus/runs/rf_1001_model.Rds', 'results/genus/runs/rf_1002_model.Rds', 'results/genus/runs/rf_1003_model.Rds', 'results/genus/runs/rf_1004_model.Rds', 'results/genus/runs/glmnet_1000_model.Rds', 'results/genus/runs/glmnet_1001_model.Rds', 'results/genus/runs/glmnet_1002_model.Rds', 'results/genus/runs/glmnet_1003_model.Rds', 'results/genus/runs/glmnet_1004_model.Rds', 'results/genus/runs/svmRadial_1000_model.Rds', 'results/genus/runs/svmRadial_1001_model.Rds', 'results/genus/runs/svmRadial_1002_model.Rds', 'results/genus/runs/svmRadial_1003_model.Rds', 'results/genus/runs/svmRadial_1004_model.Rds']\n\n\nHere’s what your Snakefile looks like now.\n\n\n\nSnakefile\n\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n\nrule targets:\n    input:\n        [f\"results/{dataset}/runs/{method}_{seed}_model.Rds\" for dataset in datasets for method in methods for seed in seeds]\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\",\n        csv=f\"data/{dataset}.csv\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n\n\nThe list comprehension gets harder to read the more for statements you add to it. So Snakemake provides a function expand() to clean this up:\n\n\n\nSnakefile\n\ndatasets = ['OTU', 'genus']\nmethods = ['rf', 'glmnet', 'svmRadial']\nseeds = range(1000, 1005)\n\nrule targets:\n    input:\n        expand(\"results/{dataset}/runs/{method}_{seed}_model.Rds\", \n                dataset = datasets, method = methods, seed = seeds)\n\nrule train_ml_model:\n    input:\n        R=\"workflow/scripts/train_ml.R\"\n    output:\n        model=\"results/{dataset}/runs/{method}_{seed}_model.Rds\"\n    script:\n        \"scripts/train_ml.R\"\n\n\nUsing expand() creates the exact same list as the list comprehension, but it’s much easier to read and add variables to."
  },
  {
    "objectID": "just-enough-python.html#functions",
    "href": "just-enough-python.html#functions",
    "title": "Just Enough Python",
    "section": "functions",
    "text": "functions\nin R:\n\n\n\nR\n\nsquare <- function(x) {\n    return(x^2)\n}\n\nsquare(2)\n\n\n[1] 4\n\n\nin Python:\n\n\n\nPython\n\ndef square(x):\n    return x**2\n\nsquare(2)\n\n\n4\n\n\nanonymous functions\nSometimes you want to write a simple function that you only use once. They’re so inconsequential you don’t even want to give them a name.\nWe’ve already used one in R2 inside sapply():\n\n\n\nR\n\nfunction(x) { x**2 }\n\n\nfunction(x) { x**2 }\n\n\nin Python you use the lambda keyword:\n\n\n\nPython\n\nlambda x: x**2\n\n\n<function <lambda> at 0x10ceeb940>\n\n\nBefore the colon, list the arguments of the function. After the colon, compute the value that the function should return.\nWhen writing Snakemake workflows, lambda functions are useful for defining input files based on the wildcards in output files. Consider a workflow where you have several rules that plot figures for a manuscript. When you initially conduct the analysis, you don’t know how the figures will be ordered in the manuscript. Once you begin drafting the manuscript, you decide that your diversity plot will be figure 1 and your error rates plot will be figure 2. You also decide to convert the figures to a different format, so the conversion step seems like a good opportunity to rename the figures. Initially you write this workflow:\n\n\n\nSnakefile\n\nrule targets:\n    input:\n        \"paper/paper.pdf\"\n\nrule convert_figure_1:\n    input:\n        tiff='figures/diversity.tiff'\n    output:\n        png=\"paper/figure_1.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule convert_figure_2:\n    input:\n        tiff='figures/error_rates.tiff'\n    output:\n        png=\"paper/figure_2.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule render_paper:\n    input:\n        Rmd=\"paper/paper.Rmd\",\n        R=\"workflow/scripts/render_rmd.R\",\n        figures=['paper/figure_1.png', 'paper/figure_2.png']\n    output:\n        pdf=\"paper/paper.pdf\"\n    script:\n        \"scripts/render_rmd.R\"\n\n\nThe rules convert_figure_1 and convert_figure_2 are a bit repetitive; they only differ by the input filenames and the figure numbers in the output filenames. Maybe this isn’t so bad with only two figures, but you might actually have 5-10 figures for a full scientific paper. We can reduce the repetitive code with a few tricks:\n\nCreate a dictionary that maps the figure numbers to the descriptive figure file names.\nUse a single rule to convert figures, using a lambda function to get the input figure filenames based on the final figure numbers.\n\n\n\n\nSnakefile\n\nfigures_dict = {1: 'diversity', 2: 'error_rates'}\n\nrule targets:\n    input:\n        \"paper/paper.pdf\"\n\nrule convert_tiff_to_png:\n    input:\n        tiff=lambda wildcards: f\"figures/{figures_dict[int(wildcards.fig_num)]}.tiff\"\n    output:\n        png=\"paper/figure_{fig_num}.png\"\n    shell:\n        \"\"\"\n        convert {input.tiff} {output.png}\n        \"\"\"\n\nrule render_paper:\n    input:\n        Rmd=\"paper/paper.Rmd\",\n        R=\"workflow/scripts/render_rmd.R\",\n        figures=expand(rules.convert_tiff_to_png.output.png, \n                       fig_num = range(1, len(figures_dict)+1))\n    output:\n        pdf=\"paper/paper.pdf\"\n    script:\n        \"scripts/render_rmd.R\"\n\n\nThis lambda function is equivalent to:\n\ndef get_fig_name_from_num(wildcards):\n    return figures_dict[int(wildcards.fig_num)]\n\nSee this full example in context here. Learn more about input functions here and params functions here."
  }
]